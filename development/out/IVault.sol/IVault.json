{"abi":[{"type":"function","name":"burnFees","inputs":[{"name":"shares","type":"uint256","internalType":"uint256"}],"outputs":[],"stateMutability":"nonpayable"},{"type":"function","name":"cancelStakeRequest","inputs":[{"name":"requestId","type":"bytes32","internalType":"bytes32"}],"outputs":[],"stateMutability":"payable"},{"type":"function","name":"cancelUnstakeRequest","inputs":[{"name":"requestId","type":"bytes32","internalType":"bytes32"}],"outputs":[],"stateMutability":"payable"},{"type":"function","name":"claimStakedShares","inputs":[{"name":"requestId","type":"bytes32","internalType":"bytes32"}],"outputs":[],"stateMutability":"payable"},{"type":"function","name":"claimUnstakedAssets","inputs":[{"name":"requestId","type":"bytes32","internalType":"bytes32"}],"outputs":[],"stateMutability":"payable"},{"type":"function","name":"closeBatch","inputs":[{"name":"_batchId","type":"bytes32","internalType":"bytes32"},{"name":"_create","type":"bool","internalType":"bool"}],"outputs":[],"stateMutability":"nonpayable"},{"type":"function","name":"createNewBatch","inputs":[],"outputs":[{"name":"batchId","type":"bytes32","internalType":"bytes32"}],"stateMutability":"nonpayable"},{"type":"function","name":"notifyManagementFeesCharged","inputs":[{"name":"_timestamp","type":"uint64","internalType":"uint64"}],"outputs":[],"stateMutability":"nonpayable"},{"type":"function","name":"notifyPerformanceFeesCharged","inputs":[{"name":"_timestamp","type":"uint64","internalType":"uint64"}],"outputs":[],"stateMutability":"nonpayable"},{"type":"function","name":"requestStake","inputs":[{"name":"to","type":"address","internalType":"address"},{"name":"kTokensAmount","type":"uint256","internalType":"uint256"}],"outputs":[{"name":"requestId","type":"bytes32","internalType":"bytes32"}],"stateMutability":"payable"},{"type":"function","name":"requestUnstake","inputs":[{"name":"to","type":"address","internalType":"address"},{"name":"stkTokenAmount","type":"uint256","internalType":"uint256"}],"outputs":[{"name":"requestId","type":"bytes32","internalType":"bytes32"}],"stateMutability":"payable"},{"type":"function","name":"setHardHurdleRate","inputs":[{"name":"_isHard","type":"bool","internalType":"bool"}],"outputs":[],"stateMutability":"nonpayable"},{"type":"function","name":"setManagementFee","inputs":[{"name":"_managementFee","type":"uint16","internalType":"uint16"}],"outputs":[],"stateMutability":"nonpayable"},{"type":"function","name":"setPaused","inputs":[{"name":"paused_","type":"bool","internalType":"bool"}],"outputs":[],"stateMutability":"nonpayable"},{"type":"function","name":"setPerformanceFee","inputs":[{"name":"_performanceFee","type":"uint16","internalType":"uint16"}],"outputs":[],"stateMutability":"nonpayable"},{"type":"function","name":"settleBatch","inputs":[{"name":"_batchId","type":"bytes32","internalType":"bytes32"}],"outputs":[],"stateMutability":"nonpayable"}],"bytecode":{"object":"0x","sourceMap":"","linkReferences":{}},"deployedBytecode":{"object":"0x","sourceMap":"","linkReferences":{}},"methodIdentifiers":{"burnFees(uint256)":"0342a6ba","cancelStakeRequest(bytes32)":"d3856009","cancelUnstakeRequest(bytes32)":"3c138a92","claimStakedShares(bytes32)":"4a1daaef","claimUnstakedAssets(bytes32)":"0f83d6d9","closeBatch(bytes32,bool)":"bb507ab9","createNewBatch()":"1875e8f5","notifyManagementFeesCharged(uint64)":"39d14dce","notifyPerformanceFeesCharged(uint64)":"9c8af15f","requestStake(address,uint256)":"58c2fd00","requestUnstake(address,uint256)":"710ba631","setHardHurdleRate(bool)":"c0b1b037","setManagementFee(uint16)":"8dd09af3","setPaused(bool)":"16c38b3c","setPerformanceFee(uint16)":"aa290e6d","settleBatch(bytes32)":"eeb8f2b5"},"rawMetadata":"{\"compiler\":{\"version\":\"0.8.30+commit.73712a01\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"}],\"name\":\"burnFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"requestId\",\"type\":\"bytes32\"}],\"name\":\"cancelStakeRequest\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"requestId\",\"type\":\"bytes32\"}],\"name\":\"cancelUnstakeRequest\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"requestId\",\"type\":\"bytes32\"}],\"name\":\"claimStakedShares\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"requestId\",\"type\":\"bytes32\"}],\"name\":\"claimUnstakedAssets\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_batchId\",\"type\":\"bytes32\"},{\"internalType\":\"bool\",\"name\":\"_create\",\"type\":\"bool\"}],\"name\":\"closeBatch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"createNewBatch\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"batchId\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_timestamp\",\"type\":\"uint64\"}],\"name\":\"notifyManagementFeesCharged\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_timestamp\",\"type\":\"uint64\"}],\"name\":\"notifyPerformanceFeesCharged\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"kTokensAmount\",\"type\":\"uint256\"}],\"name\":\"requestStake\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"requestId\",\"type\":\"bytes32\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"stkTokenAmount\",\"type\":\"uint256\"}],\"name\":\"requestUnstake\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"requestId\",\"type\":\"bytes32\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_isHard\",\"type\":\"bool\"}],\"name\":\"setHardHurdleRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_managementFee\",\"type\":\"uint16\"}],\"name\":\"setManagementFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"paused_\",\"type\":\"bool\"}],\"name\":\"setPaused\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_performanceFee\",\"type\":\"uint16\"}],\"name\":\"setPerformanceFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_batchId\",\"type\":\"bytes32\"}],\"name\":\"settleBatch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"details\":\"This interface defines the primary user entry points for the KAM protocol's retail staking system. Vaults implementing this interface provide a gateway for individual kToken holders to participate in yield generation alongside institutional flows. The system operates on a dual-token model: (1) Users deposit kTokens (1:1 backed tokens) and receive stkTokens (share tokens) that accrue yield, (2) Batch processing aggregates multiple user operations for gas efficiency and fair pricing, (3) Two-phase operations (request \\u2192 claim) enable optimal settlement coordination with the broader protocol. Key features include: asset flow coordination with kAssetRouter for virtual balance management, integration with DN vaults for yield source diversification, batch settlement system for gas-efficient operations, and automated yield distribution through share price appreciation rather than token rebasing. This approach maintains compatibility with existing DeFi infrastructure while providing transparent yield accrual for retail participants.\",\"kind\":\"dev\",\"methods\":{\"burnFees(uint256)\":{\"details\":\"This function burns fees from the vault\",\"params\":{\"shares\":\"The quantity of shares to burn\"}},\"cancelStakeRequest(bytes32)\":{\"details\":\"This function allows users to reverse their staking request before batch processing by: (1) Validating the request exists, belongs to the caller, and remains in pending status, (2) Checking the associated batch hasn't been closed or settled to prevent manipulation of finalized operations, (3) Updating request status to cancelled and removing from user's active requests tracking, (4) Reducing total pending stake amount to maintain accurate vault accounting, (5) Notifying kAssetRouter to reverse the virtual asset movement from staking vault back to DN vault, ensuring proper asset allocation, (6) Returning the originally deposited kTokens to the user's address. This cancellation mechanism provides flexibility for users who change their mind or need immediate liquidity before the batch settlement occurs. The operation is only valid during the open batch period before closure by relayers.\",\"params\":{\"requestId\":\"The unique identifier of the stake request to cancel (must be owned by caller)\"}},\"cancelUnstakeRequest(bytes32)\":{\"details\":\"This function allows users to reverse their unstaking request before batch processing by: (1) Validating the request exists, belongs to the caller, and remains in pending status, (2) Checking the associated batch hasn't been closed or settled to prevent reversal of finalized operations, (3) Updating request status to cancelled and removing from user's active requests tracking, (4) Notifying kAssetRouter to reverse the share redemption request, maintaining proper share accounting across the protocol, (5) Returning the originally transferred stkTokens from the vault back to the user's address. This cancellation mechanism enables users to maintain their staked position if market conditions change or they reconsider their unstaking decision. The stkTokens are returned without any yield impact since the batch hasn't settled. The operation is only valid during the open batch period before closure by relayers.\",\"params\":{\"requestId\":\"The unique identifier of the unstake request to cancel (must be owned by caller)\"}},\"claimStakedShares(bytes32)\":{\"details\":\"This function completes the staking process by distributing stkTokens to users after batch settlement. Process: (1) Validates batch has been settled and share prices are finalized to ensure accurate distribution, (2) Verifies request ownership and pending status to prevent unauthorized or duplicate claims, (3) Calculates stkToken amount based on original kToken deposit and settled net share price (after fees), (4) Mints stkTokens to specified recipient reflecting their proportional vault ownership, (5) Marks request as claimed to prevent future reprocessing. The net share price accounts for management and performance fees, ensuring users receive their accurate yield-adjusted position. stkTokens are ERC20-compatible shares that continue accruing yield through share price appreciation until unstaking.\",\"params\":{\"requestId\":\"The specific staking request identifier to claim rewards for\"}},\"claimUnstakedAssets(bytes32)\":{\"details\":\"This function completes the unstaking process by distributing redeemed assets to users after settlement. Process: (1) Validates batch settlement and asset distribution readiness through batch receiver verification, (2) Confirms request ownership and pending status to ensure authorized claiming, (3) Calculates kToken amount based on original stkToken redemption and settled share price including yield, (4) Burns locked stkTokens that were held during settlement period, (5) Triggers batch receiver to transfer calculated kTokens to recipient, (6) Marks request as claimed completing the unstaking cycle. The batch receiver pattern ensures asset isolation between settlement periods while enabling efficient distribution. Users receive their original investment plus proportional share of vault yields earned during their staking period.\",\"params\":{\"requestId\":\"The specific unstaking request identifier to claim assets for\"}},\"closeBatch(bytes32,bool)\":{\"details\":\"This function transitions a batch from open to closed state, finalizing the request set for settlement. Process: (1) Validates batch exists and is currently open to prevent double-closing, (2) Marks batch as closed preventing new stake/unstake requests from joining, (3) Optionally creates new batch for continued operations if _create flag is true, enabling seamless transitions. Once closed, the batch awaits settlement by kAssetRouter which will calculate final share prices and distribute yields. Only relayers can execute batch closure as part of the coordinated settlement schedule across all protocol vaults. The timing typically aligns with DN vault yield calculations to ensure accurate price discovery.\",\"params\":{\"_batchId\":\"The specific batch identifier to close (must be currently open)\",\"_create\":\"Whether to immediately create a new batch after closing for continued operations\"}},\"createNewBatch()\":{\"details\":\"This function initializes a fresh batch period for collecting staking and unstaking requests. Process: (1) Increments internal batch counter for unique identification, (2) Generates deterministic batch ID using chain-specific parameters (vault address, batch number, chainid, timestamp, asset) for collision resistance, (3) Initializes batch storage with open state enabling new request acceptance, (4) Updates vault's current batch tracking for request routing. Only relayers can call this function as part of the automated settlement schedule. The timing is typically coordinated with institutional settlement cycles to optimize capital efficiency across the protocol. Each batch remains open until explicitly closed by relayers or governance.\",\"returns\":{\"batchId\":\"Unique deterministic identifier for the newly created batch period\"}},\"notifyManagementFeesCharged(uint64)\":{\"details\":\"This function maintains accurate management fee accrual by recording when fees were last processed. Backend Coordination: (1) Off-chain systems calculate and process management fees based on time elapsed and assets under management, (2) Fees are deducted from vault assets through settlement mechanisms, (3) This function updates the tracking timestamp to prevent double-charging in future calculations. The timestamp validation ensures logical progression and prevents manipulation. Management fees accrue continuously, and proper timestamp tracking is essential for accurate pro-rata fee calculations across all vault participants.\",\"params\":{\"_timestamp\":\"The timestamp when management fees were processed (must be >= last timestamp, <= current time)\"}},\"notifyPerformanceFeesCharged(uint64)\":{\"details\":\"This function maintains accurate performance fee tracking by recording when performance fees were last calculated and charged. Backend Processing: (1) Off-chain systems evaluate vault performance against watermarks and hurdle rates, (2) Performance fees are calculated on excess returns and deducted during settlement, (3) This notification updates tracking timestamp and potentially adjusts watermark levels. The timestamp ensures proper sequencing of performance evaluations and prevents fee calculation errors. Performance fees are event-driven based on new high watermarks, making accurate timestamp tracking crucial for fair fee assessment across all users.\",\"params\":{\"_timestamp\":\"The timestamp when performance fees were processed (must be >= last timestamp, <= current time)\"}},\"requestStake(address,uint256)\":{\"details\":\"This function begins the retail staking process by: (1) Validating user has sufficient kToken balance and vault is not paused, (2) Creating a pending stake request with user-specified recipient and current batch ID for fair settlement, (3) Transferring kTokens from user to vault while updating pending stake tracking for accurate share calculations, (4) Coordinating with kAssetRouter to virtually move underlying assets from DN vault to staking vault, enabling proper asset allocation across the protocol. The request enters pending state until batch settlement, when the final share price is calculated based on vault performance. Users must later call claimStakedShares() after settlement to receive their stkTokens at the settled price. This two-phase approach ensures fair pricing for all users within a batch period.\",\"params\":{\"kTokensAmount\":\"The quantity of kTokens to stake (must not exceed user balance, cannot be zero)\",\"to\":\"The recipient address that will receive the stkTokens after successful settlement and claiming\"},\"returns\":{\"requestId\":\"Unique identifier for tracking this staking request through settlement and claiming\"}},\"requestUnstake(address,uint256)\":{\"details\":\"This function begins the retail unstaking process by: (1) Validating user has sufficient stkToken balance and vault is operational, (2) Creating pending unstake request with current batch ID for settlement coordination, (3) Transferring stkTokens from user to vault contract to maintain stable share price during settlement period, (4) Notifying kAssetRouter of share redemption request for proper accounting across vault network. The stkTokens remain locked in the vault until settlement when they are burned and equivalent kTokens (including yield) are made available. Users must later call claimUnstakedAssets() after settlement to receive their kTokens from the batch receiver contract. This two-phase design ensures accurate yield calculations and prevents share price manipulation during the settlement process.\",\"params\":{\"stkTokenAmount\":\"The quantity of stkTokens to unstake (must not exceed user balance, cannot be zero)\",\"to\":\"The recipient address that will receive the kTokens after successful settlement and claiming\"},\"returns\":{\"requestId\":\"Unique identifier for tracking this unstaking request through settlement and claiming\"}},\"setHardHurdleRate(bool)\":{\"details\":\"This function switches between soft and hard hurdle rate modes affecting performance fee calculations. Hurdle Rate Modes: (1) Soft Hurdle (_isHard = false): Performance fees are charged on all profits when returns exceed the hurdle rate threshold, providing simpler fee calculation while maintaining performance incentives, (2) Hard Hurdle (_isHard = true): Performance fees are only charged on the excess return above the hurdle rate, ensuring users keep the full hurdle rate return before any performance fees. The hurdle rate itself is set globally in the registry per asset, providing consistent benchmarks across vaults. This mechanism ensures vault operators are only rewarded for generating returns above market expectations, protecting user interests while incentivizing superior performance.\",\"params\":{\"_isHard\":\"True for hard hurdle (fees only on excess), false for soft hurdle (fees on all profits)\"}},\"setManagementFee(uint16)\":{\"details\":\"This function configures the periodic fee charged regardless of vault performance, compensating operators for ongoing vault management, risk monitoring, and operational costs. Management fees are calculated based on time elapsed since last fee charge and total assets under management. Process: (1) Validates fee rate does not exceed maximum allowed to protect users from excessive fees, (2) Updates stored management fee rate for future calculations, (3) Emits event for transparency and off-chain tracking. The fee accrues continuously and is realized during batch settlements, ensuring users see accurate net returns. Management fees are deducted from vault assets before performance fee calculations, following traditional fund management practices.\",\"params\":{\"_managementFee\":\"Annual management fee rate in basis points (1% = 100 bp, max 10000 bp)\"}},\"setPaused(bool)\":{\"details\":\"This function provides critical safety controls for vault operations by: (1) Enabling emergency admins to pause all user-facing operations during security incidents, market anomalies, or critical upgrades, (2) Preventing new stake/unstake requests and claims while preserving existing vault state and user balances, (3) Maintaining read-only access to vault data and view functions during pause periods for transparency, (4) Allowing authorized emergency admins to resume operations once issues are resolved or maintenance completed. When paused, all state-changing functions (requestStake, requestUnstake, cancelStakeRequest, cancelUnstakeRequest, claimStakedShares, claimUnstakedAssets) will revert with KSTAKINGVAULT_IS_PAUSED error. The pause mechanism serves as a circuit breaker protecting user funds during unexpected events while maintaining protocol integrity. Only emergency admins have permission to toggle this state, ensuring rapid response capabilities during critical situations without compromising decentralization principles.\",\"params\":{\"paused_\":\"The desired operational state (true = pause operations, false = resume operations)\"}},\"setPerformanceFee(uint16)\":{\"details\":\"This function configures the success fee charged when vault performance exceeds benchmark hurdle rates, aligning operator incentives with user returns. Performance fees are calculated during settlement based on share price appreciation above the watermark (highest previous share price) and hurdle rate requirements. Process: (1) Validates fee rate is within acceptable bounds for user protection, (2) Updates performance fee rate for future calculations, (3) Emits tracking event for transparency. The fee applies only to new high watermarks, preventing double-charging on recovered losses. Combined with hurdle rates, this ensures operators are rewarded for generating superior risk-adjusted returns while protecting users from excessive fee extraction.\",\"params\":{\"_performanceFee\":\"Performance fee rate in basis points charged on excess returns (max 10000 bp)\"}},\"settleBatch(bytes32)\":{\"details\":\"This function finalizes batch settlement by recording final asset values and enabling claims. Process: (1) Validates batch is closed and not already settled to prevent duplicate processing, (2) Snapshots both gross and net share prices at settlement time for accurate reward calculations, (3) Marks batch as settled enabling users to claim their staked shares or unstaked assets, (4) Completes the batch lifecycle allowing reward distribution through the claiming mechanism. Only kAssetRouter can settle batches as it coordinates yield calculations across DN vaults and manages cross-vault asset flows. Settlement triggers share price finalization based on vault performance during the batch period.\",\"params\":{\"_batchId\":\"The batch identifier to mark as settled (must be closed, not previously settled)\"}}},\"title\":\"IVault\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"burnFees(uint256)\":{\"notice\":\"Burns fees shares from the vault\"},\"cancelStakeRequest(bytes32)\":{\"notice\":\"Cancels a pending stake request and returns kTokens to the user before batch settlement\"},\"cancelUnstakeRequest(bytes32)\":{\"notice\":\"Cancels a pending unstake request and returns stkTokens to the user before batch settlement\"},\"claimStakedShares(bytes32)\":{\"notice\":\"Claims stkTokens from a settled staking batch at the finalized share price\"},\"claimUnstakedAssets(bytes32)\":{\"notice\":\"Claims kTokens plus accrued yield from a settled unstaking batch through batch receiver distribution\"},\"closeBatch(bytes32,bool)\":{\"notice\":\"Closes a batch to prevent new requests and prepare for settlement processing\"},\"createNewBatch()\":{\"notice\":\"Creates a new batch to begin aggregating user requests for the next settlement period\"},\"notifyManagementFeesCharged(uint64)\":{\"notice\":\"Updates the timestamp tracking for management fee calculations after backend fee processing\"},\"notifyPerformanceFeesCharged(uint64)\":{\"notice\":\"Updates the timestamp tracking for performance fee calculations after backend fee processing\"},\"requestStake(address,uint256)\":{\"notice\":\"Initiates kToken staking request for yield-generating stkToken shares in a batch processing system\"},\"requestUnstake(address,uint256)\":{\"notice\":\"Initiates stkToken unstaking request for kToken redemption plus accrued yield through batch processing\"},\"setHardHurdleRate(bool)\":{\"notice\":\"Configures the hurdle rate fee calculation mechanism for performance fee determination\"},\"setManagementFee(uint16)\":{\"notice\":\"Sets the annual management fee rate charged on assets under management\"},\"setPaused(bool)\":{\"notice\":\"Controls the vault's operational state for emergency situations and maintenance periods\"},\"setPerformanceFee(uint16)\":{\"notice\":\"Sets the performance fee rate charged on vault returns above hurdle rates\"},\"settleBatch(bytes32)\":{\"notice\":\"Marks a batch as settled after yield distribution and enables user claiming\"}},\"notice\":\"Core interface for retail staking operations enabling kToken holders to earn yield through vault strategies\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"src/interfaces/IVault.sol\":\"IVault\"},\"evmVersion\":\"prague\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[\":forge-std-1.9.7/=dependencies/forge-std-1.9.7/src/\",\":forge-std/=dependencies/forge-std-1.9.7/src/\",\":kam/src/=src/\",\":kam/test/=test/\",\":openzeppelin/=src/vendor/openzeppelin/\",\":solady/=src/vendor/solady/\",\":uniswap/=src/vendor/uniswap/\"],\"viaIR\":true},\"sources\":{\"src/interfaces/IVault.sol\":{\"keccak256\":\"0xb413d66d30d062c9734d2c0f070e9049a1dfd4efd74b9cefe5eeda0ee3163b83\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://6699bfdbd169ab0b87759551d69ddd4ccbee1306f7f865596f357ed11e5031e5\",\"dweb:/ipfs/QmZiaKGxpn8vQvvWBUL8V7eDfxpJzAigUuMfGiwt9GtFFo\"]},\"src/interfaces/IVaultBatch.sol\":{\"keccak256\":\"0x164c9436b0f73ee20259b32b43f08787ce6a385585af64ac91a1edee80e884d3\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://e20a62c432ff7a42cbd93ce861dfdc32d84a24a06d13fac4937a2c37bc035fba\",\"dweb:/ipfs/QmQ9W3XeNHZg66ibW8ZCDJLv2Yn3jxsD4M7hvQWU38ciQQ\"]},\"src/interfaces/IVaultClaim.sol\":{\"keccak256\":\"0xbc8653ba55535db7f9f97636eefbaac39aee5940358b8dbf374c6dd49029cf90\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://3fe53e06a6eeb51f74856ef36061939830f4bd36cac7cea57797d251aa8958b0\",\"dweb:/ipfs/Qmbsd3B9CFBdGhdtMnycY85CKFx9mfqQN2ML6quGZiP8Zk\"]},\"src/interfaces/IVaultFees.sol\":{\"keccak256\":\"0x5a718119e4189e4382d84bcfa05a5b340206c577f1fa5455fdbbcc55f85eb368\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://63a9febebe9bb631439b1a5e56f88ecab202f53f69850cd8275033f87f6ce69c\",\"dweb:/ipfs/QmeeCxhC2vJXh6GUq6eViBZW2QKCJozVV73pHRnYmYx7tb\"]}},\"version\":1}","metadata":{"compiler":{"version":"0.8.30+commit.73712a01"},"language":"Solidity","output":{"abi":[{"inputs":[{"internalType":"uint256","name":"shares","type":"uint256"}],"stateMutability":"nonpayable","type":"function","name":"burnFees"},{"inputs":[{"internalType":"bytes32","name":"requestId","type":"bytes32"}],"stateMutability":"payable","type":"function","name":"cancelStakeRequest"},{"inputs":[{"internalType":"bytes32","name":"requestId","type":"bytes32"}],"stateMutability":"payable","type":"function","name":"cancelUnstakeRequest"},{"inputs":[{"internalType":"bytes32","name":"requestId","type":"bytes32"}],"stateMutability":"payable","type":"function","name":"claimStakedShares"},{"inputs":[{"internalType":"bytes32","name":"requestId","type":"bytes32"}],"stateMutability":"payable","type":"function","name":"claimUnstakedAssets"},{"inputs":[{"internalType":"bytes32","name":"_batchId","type":"bytes32"},{"internalType":"bool","name":"_create","type":"bool"}],"stateMutability":"nonpayable","type":"function","name":"closeBatch"},{"inputs":[],"stateMutability":"nonpayable","type":"function","name":"createNewBatch","outputs":[{"internalType":"bytes32","name":"batchId","type":"bytes32"}]},{"inputs":[{"internalType":"uint64","name":"_timestamp","type":"uint64"}],"stateMutability":"nonpayable","type":"function","name":"notifyManagementFeesCharged"},{"inputs":[{"internalType":"uint64","name":"_timestamp","type":"uint64"}],"stateMutability":"nonpayable","type":"function","name":"notifyPerformanceFeesCharged"},{"inputs":[{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"kTokensAmount","type":"uint256"}],"stateMutability":"payable","type":"function","name":"requestStake","outputs":[{"internalType":"bytes32","name":"requestId","type":"bytes32"}]},{"inputs":[{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"stkTokenAmount","type":"uint256"}],"stateMutability":"payable","type":"function","name":"requestUnstake","outputs":[{"internalType":"bytes32","name":"requestId","type":"bytes32"}]},{"inputs":[{"internalType":"bool","name":"_isHard","type":"bool"}],"stateMutability":"nonpayable","type":"function","name":"setHardHurdleRate"},{"inputs":[{"internalType":"uint16","name":"_managementFee","type":"uint16"}],"stateMutability":"nonpayable","type":"function","name":"setManagementFee"},{"inputs":[{"internalType":"bool","name":"paused_","type":"bool"}],"stateMutability":"nonpayable","type":"function","name":"setPaused"},{"inputs":[{"internalType":"uint16","name":"_performanceFee","type":"uint16"}],"stateMutability":"nonpayable","type":"function","name":"setPerformanceFee"},{"inputs":[{"internalType":"bytes32","name":"_batchId","type":"bytes32"}],"stateMutability":"nonpayable","type":"function","name":"settleBatch"}],"devdoc":{"kind":"dev","methods":{"burnFees(uint256)":{"details":"This function burns fees from the vault","params":{"shares":"The quantity of shares to burn"}},"cancelStakeRequest(bytes32)":{"details":"This function allows users to reverse their staking request before batch processing by: (1) Validating the request exists, belongs to the caller, and remains in pending status, (2) Checking the associated batch hasn't been closed or settled to prevent manipulation of finalized operations, (3) Updating request status to cancelled and removing from user's active requests tracking, (4) Reducing total pending stake amount to maintain accurate vault accounting, (5) Notifying kAssetRouter to reverse the virtual asset movement from staking vault back to DN vault, ensuring proper asset allocation, (6) Returning the originally deposited kTokens to the user's address. This cancellation mechanism provides flexibility for users who change their mind or need immediate liquidity before the batch settlement occurs. The operation is only valid during the open batch period before closure by relayers.","params":{"requestId":"The unique identifier of the stake request to cancel (must be owned by caller)"}},"cancelUnstakeRequest(bytes32)":{"details":"This function allows users to reverse their unstaking request before batch processing by: (1) Validating the request exists, belongs to the caller, and remains in pending status, (2) Checking the associated batch hasn't been closed or settled to prevent reversal of finalized operations, (3) Updating request status to cancelled and removing from user's active requests tracking, (4) Notifying kAssetRouter to reverse the share redemption request, maintaining proper share accounting across the protocol, (5) Returning the originally transferred stkTokens from the vault back to the user's address. This cancellation mechanism enables users to maintain their staked position if market conditions change or they reconsider their unstaking decision. The stkTokens are returned without any yield impact since the batch hasn't settled. The operation is only valid during the open batch period before closure by relayers.","params":{"requestId":"The unique identifier of the unstake request to cancel (must be owned by caller)"}},"claimStakedShares(bytes32)":{"details":"This function completes the staking process by distributing stkTokens to users after batch settlement. Process: (1) Validates batch has been settled and share prices are finalized to ensure accurate distribution, (2) Verifies request ownership and pending status to prevent unauthorized or duplicate claims, (3) Calculates stkToken amount based on original kToken deposit and settled net share price (after fees), (4) Mints stkTokens to specified recipient reflecting their proportional vault ownership, (5) Marks request as claimed to prevent future reprocessing. The net share price accounts for management and performance fees, ensuring users receive their accurate yield-adjusted position. stkTokens are ERC20-compatible shares that continue accruing yield through share price appreciation until unstaking.","params":{"requestId":"The specific staking request identifier to claim rewards for"}},"claimUnstakedAssets(bytes32)":{"details":"This function completes the unstaking process by distributing redeemed assets to users after settlement. Process: (1) Validates batch settlement and asset distribution readiness through batch receiver verification, (2) Confirms request ownership and pending status to ensure authorized claiming, (3) Calculates kToken amount based on original stkToken redemption and settled share price including yield, (4) Burns locked stkTokens that were held during settlement period, (5) Triggers batch receiver to transfer calculated kTokens to recipient, (6) Marks request as claimed completing the unstaking cycle. The batch receiver pattern ensures asset isolation between settlement periods while enabling efficient distribution. Users receive their original investment plus proportional share of vault yields earned during their staking period.","params":{"requestId":"The specific unstaking request identifier to claim assets for"}},"closeBatch(bytes32,bool)":{"details":"This function transitions a batch from open to closed state, finalizing the request set for settlement. Process: (1) Validates batch exists and is currently open to prevent double-closing, (2) Marks batch as closed preventing new stake/unstake requests from joining, (3) Optionally creates new batch for continued operations if _create flag is true, enabling seamless transitions. Once closed, the batch awaits settlement by kAssetRouter which will calculate final share prices and distribute yields. Only relayers can execute batch closure as part of the coordinated settlement schedule across all protocol vaults. The timing typically aligns with DN vault yield calculations to ensure accurate price discovery.","params":{"_batchId":"The specific batch identifier to close (must be currently open)","_create":"Whether to immediately create a new batch after closing for continued operations"}},"createNewBatch()":{"details":"This function initializes a fresh batch period for collecting staking and unstaking requests. Process: (1) Increments internal batch counter for unique identification, (2) Generates deterministic batch ID using chain-specific parameters (vault address, batch number, chainid, timestamp, asset) for collision resistance, (3) Initializes batch storage with open state enabling new request acceptance, (4) Updates vault's current batch tracking for request routing. Only relayers can call this function as part of the automated settlement schedule. The timing is typically coordinated with institutional settlement cycles to optimize capital efficiency across the protocol. Each batch remains open until explicitly closed by relayers or governance.","returns":{"batchId":"Unique deterministic identifier for the newly created batch period"}},"notifyManagementFeesCharged(uint64)":{"details":"This function maintains accurate management fee accrual by recording when fees were last processed. Backend Coordination: (1) Off-chain systems calculate and process management fees based on time elapsed and assets under management, (2) Fees are deducted from vault assets through settlement mechanisms, (3) This function updates the tracking timestamp to prevent double-charging in future calculations. The timestamp validation ensures logical progression and prevents manipulation. Management fees accrue continuously, and proper timestamp tracking is essential for accurate pro-rata fee calculations across all vault participants.","params":{"_timestamp":"The timestamp when management fees were processed (must be >= last timestamp, <= current time)"}},"notifyPerformanceFeesCharged(uint64)":{"details":"This function maintains accurate performance fee tracking by recording when performance fees were last calculated and charged. Backend Processing: (1) Off-chain systems evaluate vault performance against watermarks and hurdle rates, (2) Performance fees are calculated on excess returns and deducted during settlement, (3) This notification updates tracking timestamp and potentially adjusts watermark levels. The timestamp ensures proper sequencing of performance evaluations and prevents fee calculation errors. Performance fees are event-driven based on new high watermarks, making accurate timestamp tracking crucial for fair fee assessment across all users.","params":{"_timestamp":"The timestamp when performance fees were processed (must be >= last timestamp, <= current time)"}},"requestStake(address,uint256)":{"details":"This function begins the retail staking process by: (1) Validating user has sufficient kToken balance and vault is not paused, (2) Creating a pending stake request with user-specified recipient and current batch ID for fair settlement, (3) Transferring kTokens from user to vault while updating pending stake tracking for accurate share calculations, (4) Coordinating with kAssetRouter to virtually move underlying assets from DN vault to staking vault, enabling proper asset allocation across the protocol. The request enters pending state until batch settlement, when the final share price is calculated based on vault performance. Users must later call claimStakedShares() after settlement to receive their stkTokens at the settled price. This two-phase approach ensures fair pricing for all users within a batch period.","params":{"kTokensAmount":"The quantity of kTokens to stake (must not exceed user balance, cannot be zero)","to":"The recipient address that will receive the stkTokens after successful settlement and claiming"},"returns":{"requestId":"Unique identifier for tracking this staking request through settlement and claiming"}},"requestUnstake(address,uint256)":{"details":"This function begins the retail unstaking process by: (1) Validating user has sufficient stkToken balance and vault is operational, (2) Creating pending unstake request with current batch ID for settlement coordination, (3) Transferring stkTokens from user to vault contract to maintain stable share price during settlement period, (4) Notifying kAssetRouter of share redemption request for proper accounting across vault network. The stkTokens remain locked in the vault until settlement when they are burned and equivalent kTokens (including yield) are made available. Users must later call claimUnstakedAssets() after settlement to receive their kTokens from the batch receiver contract. This two-phase design ensures accurate yield calculations and prevents share price manipulation during the settlement process.","params":{"stkTokenAmount":"The quantity of stkTokens to unstake (must not exceed user balance, cannot be zero)","to":"The recipient address that will receive the kTokens after successful settlement and claiming"},"returns":{"requestId":"Unique identifier for tracking this unstaking request through settlement and claiming"}},"setHardHurdleRate(bool)":{"details":"This function switches between soft and hard hurdle rate modes affecting performance fee calculations. Hurdle Rate Modes: (1) Soft Hurdle (_isHard = false): Performance fees are charged on all profits when returns exceed the hurdle rate threshold, providing simpler fee calculation while maintaining performance incentives, (2) Hard Hurdle (_isHard = true): Performance fees are only charged on the excess return above the hurdle rate, ensuring users keep the full hurdle rate return before any performance fees. The hurdle rate itself is set globally in the registry per asset, providing consistent benchmarks across vaults. This mechanism ensures vault operators are only rewarded for generating returns above market expectations, protecting user interests while incentivizing superior performance.","params":{"_isHard":"True for hard hurdle (fees only on excess), false for soft hurdle (fees on all profits)"}},"setManagementFee(uint16)":{"details":"This function configures the periodic fee charged regardless of vault performance, compensating operators for ongoing vault management, risk monitoring, and operational costs. Management fees are calculated based on time elapsed since last fee charge and total assets under management. Process: (1) Validates fee rate does not exceed maximum allowed to protect users from excessive fees, (2) Updates stored management fee rate for future calculations, (3) Emits event for transparency and off-chain tracking. The fee accrues continuously and is realized during batch settlements, ensuring users see accurate net returns. Management fees are deducted from vault assets before performance fee calculations, following traditional fund management practices.","params":{"_managementFee":"Annual management fee rate in basis points (1% = 100 bp, max 10000 bp)"}},"setPaused(bool)":{"details":"This function provides critical safety controls for vault operations by: (1) Enabling emergency admins to pause all user-facing operations during security incidents, market anomalies, or critical upgrades, (2) Preventing new stake/unstake requests and claims while preserving existing vault state and user balances, (3) Maintaining read-only access to vault data and view functions during pause periods for transparency, (4) Allowing authorized emergency admins to resume operations once issues are resolved or maintenance completed. When paused, all state-changing functions (requestStake, requestUnstake, cancelStakeRequest, cancelUnstakeRequest, claimStakedShares, claimUnstakedAssets) will revert with KSTAKINGVAULT_IS_PAUSED error. The pause mechanism serves as a circuit breaker protecting user funds during unexpected events while maintaining protocol integrity. Only emergency admins have permission to toggle this state, ensuring rapid response capabilities during critical situations without compromising decentralization principles.","params":{"paused_":"The desired operational state (true = pause operations, false = resume operations)"}},"setPerformanceFee(uint16)":{"details":"This function configures the success fee charged when vault performance exceeds benchmark hurdle rates, aligning operator incentives with user returns. Performance fees are calculated during settlement based on share price appreciation above the watermark (highest previous share price) and hurdle rate requirements. Process: (1) Validates fee rate is within acceptable bounds for user protection, (2) Updates performance fee rate for future calculations, (3) Emits tracking event for transparency. The fee applies only to new high watermarks, preventing double-charging on recovered losses. Combined with hurdle rates, this ensures operators are rewarded for generating superior risk-adjusted returns while protecting users from excessive fee extraction.","params":{"_performanceFee":"Performance fee rate in basis points charged on excess returns (max 10000 bp)"}},"settleBatch(bytes32)":{"details":"This function finalizes batch settlement by recording final asset values and enabling claims. Process: (1) Validates batch is closed and not already settled to prevent duplicate processing, (2) Snapshots both gross and net share prices at settlement time for accurate reward calculations, (3) Marks batch as settled enabling users to claim their staked shares or unstaked assets, (4) Completes the batch lifecycle allowing reward distribution through the claiming mechanism. Only kAssetRouter can settle batches as it coordinates yield calculations across DN vaults and manages cross-vault asset flows. Settlement triggers share price finalization based on vault performance during the batch period.","params":{"_batchId":"The batch identifier to mark as settled (must be closed, not previously settled)"}}},"version":1},"userdoc":{"kind":"user","methods":{"burnFees(uint256)":{"notice":"Burns fees shares from the vault"},"cancelStakeRequest(bytes32)":{"notice":"Cancels a pending stake request and returns kTokens to the user before batch settlement"},"cancelUnstakeRequest(bytes32)":{"notice":"Cancels a pending unstake request and returns stkTokens to the user before batch settlement"},"claimStakedShares(bytes32)":{"notice":"Claims stkTokens from a settled staking batch at the finalized share price"},"claimUnstakedAssets(bytes32)":{"notice":"Claims kTokens plus accrued yield from a settled unstaking batch through batch receiver distribution"},"closeBatch(bytes32,bool)":{"notice":"Closes a batch to prevent new requests and prepare for settlement processing"},"createNewBatch()":{"notice":"Creates a new batch to begin aggregating user requests for the next settlement period"},"notifyManagementFeesCharged(uint64)":{"notice":"Updates the timestamp tracking for management fee calculations after backend fee processing"},"notifyPerformanceFeesCharged(uint64)":{"notice":"Updates the timestamp tracking for performance fee calculations after backend fee processing"},"requestStake(address,uint256)":{"notice":"Initiates kToken staking request for yield-generating stkToken shares in a batch processing system"},"requestUnstake(address,uint256)":{"notice":"Initiates stkToken unstaking request for kToken redemption plus accrued yield through batch processing"},"setHardHurdleRate(bool)":{"notice":"Configures the hurdle rate fee calculation mechanism for performance fee determination"},"setManagementFee(uint16)":{"notice":"Sets the annual management fee rate charged on assets under management"},"setPaused(bool)":{"notice":"Controls the vault's operational state for emergency situations and maintenance periods"},"setPerformanceFee(uint16)":{"notice":"Sets the performance fee rate charged on vault returns above hurdle rates"},"settleBatch(bytes32)":{"notice":"Marks a batch as settled after yield distribution and enables user claiming"}},"version":1}},"settings":{"remappings":["forge-std-1.9.7/=dependencies/forge-std-1.9.7/src/","forge-std/=dependencies/forge-std-1.9.7/src/","kam/src/=src/","kam/test/=test/","openzeppelin/=src/vendor/openzeppelin/","solady/=src/vendor/solady/","uniswap/=src/vendor/uniswap/"],"optimizer":{"enabled":true,"runs":10000},"metadata":{"bytecodeHash":"ipfs"},"compilationTarget":{"src/interfaces/IVault.sol":"IVault"},"evmVersion":"prague","libraries":{},"viaIR":true},"sources":{"src/interfaces/IVault.sol":{"keccak256":"0xb413d66d30d062c9734d2c0f070e9049a1dfd4efd74b9cefe5eeda0ee3163b83","urls":["bzz-raw://6699bfdbd169ab0b87759551d69ddd4ccbee1306f7f865596f357ed11e5031e5","dweb:/ipfs/QmZiaKGxpn8vQvvWBUL8V7eDfxpJzAigUuMfGiwt9GtFFo"],"license":"MIT"},"src/interfaces/IVaultBatch.sol":{"keccak256":"0x164c9436b0f73ee20259b32b43f08787ce6a385585af64ac91a1edee80e884d3","urls":["bzz-raw://e20a62c432ff7a42cbd93ce861dfdc32d84a24a06d13fac4937a2c37bc035fba","dweb:/ipfs/QmQ9W3XeNHZg66ibW8ZCDJLv2Yn3jxsD4M7hvQWU38ciQQ"],"license":"MIT"},"src/interfaces/IVaultClaim.sol":{"keccak256":"0xbc8653ba55535db7f9f97636eefbaac39aee5940358b8dbf374c6dd49029cf90","urls":["bzz-raw://3fe53e06a6eeb51f74856ef36061939830f4bd36cac7cea57797d251aa8958b0","dweb:/ipfs/Qmbsd3B9CFBdGhdtMnycY85CKFx9mfqQN2ML6quGZiP8Zk"],"license":"MIT"},"src/interfaces/IVaultFees.sol":{"keccak256":"0x5a718119e4189e4382d84bcfa05a5b340206c577f1fa5455fdbbcc55f85eb368","urls":["bzz-raw://63a9febebe9bb631439b1a5e56f88ecab202f53f69850cd8275033f87f6ce69c","dweb:/ipfs/QmeeCxhC2vJXh6GUq6eViBZW2QKCJozVV73pHRnYmYx7tb"],"license":"MIT"}},"version":1},"storageLayout":{"storage":[],"types":{}},"ast":{"absolutePath":"src/interfaces/IVault.sol","id":50958,"exportedSymbols":{"IVault":[50957],"IVaultBatch":[51086],"IVaultClaim":[51102],"IVaultFees":[51136]},"nodeType":"SourceUnit","src":"32:8480:45","nodes":[{"id":50905,"nodeType":"PragmaDirective","src":"32:23:45","nodes":[],"literals":["solidity","^","0.8",".4"]},{"id":50907,"nodeType":"ImportDirective","src":"57:48:45","nodes":[],"absolutePath":"src/interfaces/IVaultBatch.sol","file":"./IVaultBatch.sol","nameLocation":"-1:-1:-1","scope":50958,"sourceUnit":51087,"symbolAliases":[{"foreign":{"id":50906,"name":"IVaultBatch","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":51086,"src":"66:11:45","typeDescriptions":{}},"nameLocation":"-1:-1:-1"}],"unitAlias":""},{"id":50909,"nodeType":"ImportDirective","src":"106:48:45","nodes":[],"absolutePath":"src/interfaces/IVaultClaim.sol","file":"./IVaultClaim.sol","nameLocation":"-1:-1:-1","scope":50958,"sourceUnit":51103,"symbolAliases":[{"foreign":{"id":50908,"name":"IVaultClaim","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":51102,"src":"115:11:45","typeDescriptions":{}},"nameLocation":"-1:-1:-1"}],"unitAlias":""},{"id":50911,"nodeType":"ImportDirective","src":"155:46:45","nodes":[],"absolutePath":"src/interfaces/IVaultFees.sol","file":"./IVaultFees.sol","nameLocation":"-1:-1:-1","scope":50958,"sourceUnit":51137,"symbolAliases":[{"foreign":{"id":50910,"name":"IVaultFees","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":51136,"src":"164:10:45","typeDescriptions":{}},"nameLocation":"-1:-1:-1"}],"unitAlias":""},{"id":50957,"nodeType":"ContractDefinition","src":"1428:7083:45","nodes":[{"id":50928,"nodeType":"FunctionDefinition","src":"3018:102:45","nodes":[],"documentation":{"id":50919,"nodeType":"StructuredDocumentation","src":"1678:1335:45","text":"@notice Initiates kToken staking request for yield-generating stkToken shares in a batch processing system\n @dev This function begins the retail staking process by: (1) Validating user has sufficient kToken balance\n and vault is not paused, (2) Creating a pending stake request with user-specified recipient and current\n batch ID for fair settlement, (3) Transferring kTokens from user to vault while updating pending stake\n tracking for accurate share calculations, (4) Coordinating with kAssetRouter to virtually move underlying\n assets from DN vault to staking vault, enabling proper asset allocation across the protocol. The request\n enters pending state until batch settlement, when the final share price is calculated based on vault\n performance. Users must later call claimStakedShares() after settlement to receive their stkTokens at\n the settled price. This two-phase approach ensures fair pricing for all users within a batch period.\n @param to The recipient address that will receive the stkTokens after successful settlement and claiming\n @param kTokensAmount The quantity of kTokens to stake (must not exceed user balance, cannot be zero)\n @return requestId Unique identifier for tracking this staking request through settlement and claiming"},"functionSelector":"58c2fd00","implemented":false,"kind":"function","modifiers":[],"name":"requestStake","nameLocation":"3027:12:45","parameters":{"id":50924,"nodeType":"ParameterList","parameters":[{"constant":false,"id":50921,"mutability":"mutable","name":"to","nameLocation":"3048:2:45","nodeType":"VariableDeclaration","scope":50928,"src":"3040:10:45","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"typeName":{"id":50920,"name":"address","nodeType":"ElementaryTypeName","src":"3040:7:45","stateMutability":"nonpayable","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"visibility":"internal"},{"constant":false,"id":50923,"mutability":"mutable","name":"kTokensAmount","nameLocation":"3060:13:45","nodeType":"VariableDeclaration","scope":50928,"src":"3052:21:45","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"},"typeName":{"id":50922,"name":"uint256","nodeType":"ElementaryTypeName","src":"3052:7:45","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"visibility":"internal"}],"src":"3039:35:45"},"returnParameters":{"id":50927,"nodeType":"ParameterList","parameters":[{"constant":false,"id":50926,"mutability":"mutable","name":"requestId","nameLocation":"3109:9:45","nodeType":"VariableDeclaration","scope":50928,"src":"3101:17:45","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"},"typeName":{"id":50925,"name":"bytes32","nodeType":"ElementaryTypeName","src":"3101:7:45","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"visibility":"internal"}],"src":"3100:19:45"},"scope":50957,"stateMutability":"payable","virtual":false,"visibility":"external"},{"id":50938,"nodeType":"FunctionDefinition","src":"4477:105:45","nodes":[],"documentation":{"id":50929,"nodeType":"StructuredDocumentation","src":"3126:1346:45","text":"@notice Initiates stkToken unstaking request for kToken redemption plus accrued yield through batch processing\n @dev This function begins the retail unstaking process by: (1) Validating user has sufficient stkToken balance\n and vault is operational, (2) Creating pending unstake request with current batch ID for settlement\n coordination,\n (3) Transferring stkTokens from user to vault contract to maintain stable share price during settlement period,\n (4) Notifying kAssetRouter of share redemption request for proper accounting across vault network. The stkTokens\n remain locked in the vault until settlement when they are burned and equivalent kTokens (including yield) are\n made available. Users must later call claimUnstakedAssets() after settlement to receive their kTokens from\n the batch receiver contract. This two-phase design ensures accurate yield calculations and prevents share\n price manipulation during the settlement process.\n @param to The recipient address that will receive the kTokens after successful settlement and claiming\n @param stkTokenAmount The quantity of stkTokens to unstake (must not exceed user balance, cannot be zero)\n @return requestId Unique identifier for tracking this unstaking request through settlement and claiming"},"functionSelector":"710ba631","implemented":false,"kind":"function","modifiers":[],"name":"requestUnstake","nameLocation":"4486:14:45","parameters":{"id":50934,"nodeType":"ParameterList","parameters":[{"constant":false,"id":50931,"mutability":"mutable","name":"to","nameLocation":"4509:2:45","nodeType":"VariableDeclaration","scope":50938,"src":"4501:10:45","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"typeName":{"id":50930,"name":"address","nodeType":"ElementaryTypeName","src":"4501:7:45","stateMutability":"nonpayable","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"visibility":"internal"},{"constant":false,"id":50933,"mutability":"mutable","name":"stkTokenAmount","nameLocation":"4521:14:45","nodeType":"VariableDeclaration","scope":50938,"src":"4513:22:45","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"},"typeName":{"id":50932,"name":"uint256","nodeType":"ElementaryTypeName","src":"4513:7:45","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"visibility":"internal"}],"src":"4500:36:45"},"returnParameters":{"id":50937,"nodeType":"ParameterList","parameters":[{"constant":false,"id":50936,"mutability":"mutable","name":"requestId","nameLocation":"4571:9:45","nodeType":"VariableDeclaration","scope":50938,"src":"4563:17:45","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"},"typeName":{"id":50935,"name":"bytes32","nodeType":"ElementaryTypeName","src":"4563:7:45","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"visibility":"internal"}],"src":"4562:19:45"},"scope":50957,"stateMutability":"payable","virtual":false,"visibility":"external"},{"id":50944,"nodeType":"FunctionDefinition","src":"5770:64:45","nodes":[],"documentation":{"id":50939,"nodeType":"StructuredDocumentation","src":"4588:1177:45","text":"@notice Cancels a pending stake request and returns kTokens to the user before batch settlement\n @dev This function allows users to reverse their staking request before batch processing by: (1) Validating\n the request exists, belongs to the caller, and remains in pending status, (2) Checking the associated batch\n hasn't been closed or settled to prevent manipulation of finalized operations, (3) Updating request status\n to cancelled and removing from user's active requests tracking, (4) Reducing total pending stake amount\n to maintain accurate vault accounting, (5) Notifying kAssetRouter to reverse the virtual asset movement\n from staking vault back to DN vault, ensuring proper asset allocation, (6) Returning the originally deposited\n kTokens to the user's address. This cancellation mechanism provides flexibility for users who change their\n mind or need immediate liquidity before the batch settlement occurs. The operation is only valid during\n the open batch period before closure by relayers.\n @param requestId The unique identifier of the stake request to cancel (must be owned by caller)"},"functionSelector":"d3856009","implemented":false,"kind":"function","modifiers":[],"name":"cancelStakeRequest","nameLocation":"5779:18:45","parameters":{"id":50942,"nodeType":"ParameterList","parameters":[{"constant":false,"id":50941,"mutability":"mutable","name":"requestId","nameLocation":"5806:9:45","nodeType":"VariableDeclaration","scope":50944,"src":"5798:17:45","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"},"typeName":{"id":50940,"name":"bytes32","nodeType":"ElementaryTypeName","src":"5798:7:45","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"visibility":"internal"}],"src":"5797:19:45"},"returnParameters":{"id":50943,"nodeType":"ParameterList","parameters":[],"src":"5833:0:45"},"scope":50957,"stateMutability":"payable","virtual":false,"visibility":"external"},{"id":50950,"nodeType":"FunctionDefinition","src":"7048:66:45","nodes":[],"documentation":{"id":50945,"nodeType":"StructuredDocumentation","src":"5840:1203:45","text":"@notice Cancels a pending unstake request and returns stkTokens to the user before batch settlement\n @dev This function allows users to reverse their unstaking request before batch processing by: (1) Validating\n the request exists, belongs to the caller, and remains in pending status, (2) Checking the associated batch\n hasn't been closed or settled to prevent reversal of finalized operations, (3) Updating request status\n to cancelled and removing from user's active requests tracking, (4) Notifying kAssetRouter to reverse the\n share redemption request, maintaining proper share accounting across the protocol, (5) Returning the originally\n transferred stkTokens from the vault back to the user's address. This cancellation mechanism enables users\n to maintain their staked position if market conditions change or they reconsider their unstaking decision.\n The stkTokens are returned without any yield impact since the batch hasn't settled. The operation is only\n valid during the open batch period before closure by relayers.\n @param requestId The unique identifier of the unstake request to cancel (must be owned by caller)"},"functionSelector":"3c138a92","implemented":false,"kind":"function","modifiers":[],"name":"cancelUnstakeRequest","nameLocation":"7057:20:45","parameters":{"id":50948,"nodeType":"ParameterList","parameters":[{"constant":false,"id":50947,"mutability":"mutable","name":"requestId","nameLocation":"7086:9:45","nodeType":"VariableDeclaration","scope":50950,"src":"7078:17:45","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"},"typeName":{"id":50946,"name":"bytes32","nodeType":"ElementaryTypeName","src":"7078:7:45","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"visibility":"internal"}],"src":"7077:19:45"},"returnParameters":{"id":50949,"nodeType":"ParameterList","parameters":[],"src":"7113:0:45"},"scope":50957,"stateMutability":"payable","virtual":false,"visibility":"external"},{"id":50956,"nodeType":"FunctionDefinition","src":"8467:42:45","nodes":[],"documentation":{"id":50951,"nodeType":"StructuredDocumentation","src":"7120:1342:45","text":"@notice Controls the vault's operational state for emergency situations and maintenance periods\n @dev This function provides critical safety controls for vault operations by: (1) Enabling emergency admins\n to pause all user-facing operations during security incidents, market anomalies, or critical upgrades,\n (2) Preventing new stake/unstake requests and claims while preserving existing vault state and user balances,\n (3) Maintaining read-only access to vault data and view functions during pause periods for transparency,\n (4) Allowing authorized emergency admins to resume operations once issues are resolved or maintenance completed.\n When paused, all state-changing functions (requestStake, requestUnstake, cancelStakeRequest,\n cancelUnstakeRequest,\n claimStakedShares, claimUnstakedAssets) will revert with KSTAKINGVAULT_IS_PAUSED error. The pause mechanism\n serves as a circuit breaker protecting user funds during unexpected events while maintaining protocol integrity.\n Only emergency admins have permission to toggle this state, ensuring rapid response capabilities during critical\n situations without compromising decentralization principles.\n @param paused_ The desired operational state (true = pause operations, false = resume operations)"},"functionSelector":"16c38b3c","implemented":false,"kind":"function","modifiers":[],"name":"setPaused","nameLocation":"8476:9:45","parameters":{"id":50954,"nodeType":"ParameterList","parameters":[{"constant":false,"id":50953,"mutability":"mutable","name":"paused_","nameLocation":"8491:7:45","nodeType":"VariableDeclaration","scope":50956,"src":"8486:12:45","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"},"typeName":{"id":50952,"name":"bool","nodeType":"ElementaryTypeName","src":"8486:4:45","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},"visibility":"internal"}],"src":"8485:14:45"},"returnParameters":{"id":50955,"nodeType":"ParameterList","parameters":[],"src":"8508:0:45"},"scope":50957,"stateMutability":"nonpayable","virtual":false,"visibility":"external"}],"abstract":false,"baseContracts":[{"baseName":{"id":50913,"name":"IVaultBatch","nameLocations":["1448:11:45"],"nodeType":"IdentifierPath","referencedDeclaration":51086,"src":"1448:11:45"},"id":50914,"nodeType":"InheritanceSpecifier","src":"1448:11:45"},{"baseName":{"id":50915,"name":"IVaultClaim","nameLocations":["1461:11:45"],"nodeType":"IdentifierPath","referencedDeclaration":51102,"src":"1461:11:45"},"id":50916,"nodeType":"InheritanceSpecifier","src":"1461:11:45"},{"baseName":{"id":50917,"name":"IVaultFees","nameLocations":["1474:10:45"],"nodeType":"IdentifierPath","referencedDeclaration":51136,"src":"1474:10:45"},"id":50918,"nodeType":"InheritanceSpecifier","src":"1474:10:45"}],"canonicalName":"IVault","contractDependencies":[],"contractKind":"interface","documentation":{"id":50912,"nodeType":"StructuredDocumentation","src":"203:1225:45","text":"@title IVault\n @notice Core interface for retail staking operations enabling kToken holders to earn yield through vault strategies\n @dev This interface defines the primary user entry points for the KAM protocol's retail staking system. Vaults\n implementing this interface provide a gateway for individual kToken holders to participate in yield generation\n alongside institutional flows. The system operates on a dual-token model: (1) Users deposit kTokens (1:1 backed\n tokens) and receive stkTokens (share tokens) that accrue yield, (2) Batch processing aggregates multiple user\n operations for gas efficiency and fair pricing, (3) Two-phase operations (request → claim) enable optimal\n settlement coordination with the broader protocol. Key features include: asset flow coordination with kAssetRouter\n for virtual balance management, integration with DN vaults for yield source diversification, batch settlement\n system for gas-efficient operations, and automated yield distribution through share price appreciation rather\n than token rebasing. This approach maintains compatibility with existing DeFi infrastructure while providing\n transparent yield accrual for retail participants."},"fullyImplemented":false,"linearizedBaseContracts":[50957,51136,51102,51086],"name":"IVault","nameLocation":"1438:6:45","scope":50958,"usedErrors":[],"usedEvents":[]}],"license":"MIT"},"id":45}